# Data-structure-learning-notes
c++数据结构学习笔记
(1)
class my{
public:
	    ~my(){cout<<"my"<<endl;};
public:
	int a;
	double b;
	char c;
	double d;
	int e;
};

class my1 :public my{
public:
	  ~my1(){cout<<"my1"<<endl;};

public:
	int f;
	short g;
};
class you{
public:
	  ~you(){cout<<"you"<<endl;};

public:
	int aa;
	double bb;
	char cc;
};

class my2 :public my1, public you{
public:
	 virtual ~my2(){cout<<"my2"<<endl;};

public:
	char h;
};



int main() {
      my2 abc;
	cout<<sizeof(my2)<<endl;
	printf(“%p\n",&my2::h);
	printf("%p\n",&abc);
	printf("%p\n",&abc.a);
	printf("%p\n",&abc.h);
	return 0;
}
与前例唯一的区别是my2引入了虚函数。
my2对象先安排1个指针vptr
再安排my1对象和you对象
最后，分配char h。
(2)
class my{
public:
	    ~my(){cout<<"my"<<endl;};
public:
	int a;
	double b;
	char c;
	double d;
	int e;
};

class my1 :public my{
public:
	  ~my1(){cout<<"my1"<<endl;};

public:
	int f;
	short g;
};
class you{
public:
	 virtual ~you(){cout<<"you"<<endl;};

public:
	int aa;
	double bb;
	char cc;
};

class my2 :public my1, public you{
public:
	 ~my2(){cout<<"my2"<<endl;};

public:
	char h;
};



int main() {
	my2 abc;
	printf("%d\n", sizeof(my2));
	printf("%p\n",&abc);
	printf("%p\n",&abc.a);
	printf("%p\n",&abc.aa);
	printf("%p\n",&abc.h);
return 0;
}
80
0x7fff5f5dc600
0x7fff5f5dc620
0x7fff5f5dc608
0x7fff5f5dc64a
与前例的区别是you引入了虚函数。
这时面临先my1或you的选择，因为you有虚拟函数，为了将vptr尽量安排在相对地址0，所以先安排you，再安排my1，最后安排h。
继承多个父类时，编译器可以自由的安排次序。
h都是49，说明先安排了my1再you。
